#include <iostream>
#include <new>                          // Define classe bad_alloc
#include <stdexcept>                    // Define classes de excesões

using namespace std;

class delEmptyList : public runtime_error       // Define classe de exception para erro de lista vazia
{
public:
    delEmptyList() : runtime_error("Attempted to delete data from empty list") {}      // Define função de excessão
};

class node                              // Definição da classe nó
{
private:
    int data;                           // Dado do nó
    node *nextNode;                     // Ponteiro para o próximo nó
    node *lastNode;                     // Ponteiro para o nó anterior
public:
    node(int);                          // Método construtor do nó
    ~node();                            // Método destrutor do nó
    void pushData(int);                 // Método para redefinir o dado do nó
    void pushNext(node*);               // Método para redefinir próximo nó
    void pushLast(node*);               // Método para redefinir nó anterior
    int getData(void);                  // Método para receber valor do nó
    node *getNext(void);                // Método para receber ponteiro para o próximo nó
    node *getLast(void);                // Método para receber ponteiro para o nó anterior
};

node::node(int newData)                 // Construtor do nó
{
    pushData(newData);                  // Adiciona dado ao nó
}

node::~node()                           // Destrutor do nó
{

}

void node::pushData(int newData)        // Método para redefinir o dado do nó
{
    data = newData;                     // Modifica o dado do nó
}

void node::pushNext(node *next)         // Método para redefinir próximo nó
{
    nextNode = next;                    // Redireciona o ponteiro
}

void node::pushLast(node *last)         // Método para redefinir nó anterior
{
    lastNode = last;                    // Redireciona o ponteiro
}

int node::getData()                     // Método para receber valor do nó
{
    return data;                        // Retorna o valor do nó
}

node *node::getNext()                   // Método para receber ponteiro para o próximo nó
{
    return nextNode;                    // Retorna o ponteiro para o próximo nó
}

node *node::getLast()                   // Método para receber ponteiro para o nó anterior
{
    return lastNode;                    // Retorna o ponteiro para o nó anterior
}

class linkedList                        // Definição da classe lista Ligada
{
private:
    node *startNode;                    // Ponteiro para o nó inicial
    node *endNode;                      // Ponteiro para o nó final
    int listSize;                       // Tamanho da lista
public:
    linkedList();                       // Método construtor da lista
    ~linkedList();                      // Método destrutor da lista
    bool isEmpty(void);                 // Método que verifica que a lista está vazia
    int getSize();                      // Método que retorna o tamanho da lista
    node *getStart(void);               // Método que retorna o ponteiro para o nó inicial
    node *getEnd(void);                 // Método que retorna o ponteiro para o nó final
    void addStart(int);                 // Método que adiciona um novo nó no início da lista
    void addEnd(int);                   // Método que adiciona um novo nó no final da lista
    void delStart(void);                // Método que deleta o nó no início da lista
    void delEnd(void);                  // Método que deleta o nó no final da lista
};

linkedList::linkedList()                // Método construtor da lista
{
    listSize = 0;                       // Define tamanho inicial zero
    startNode = nullptr;                // Define nó inicial nulo
    endNode = nullptr;                  // Define nó final nulo
}

linkedList::~linkedList()               // Método destrutor da lista
{

}

bool linkedList::isEmpty()              // Método que verifica que a lista está vazia
{
    if(listSize == 0)                   // Se a lista está vazia
    {
        return true;                    // Retorna verdadeiro
    }
    else                                // Caso não seja vazia
    {
        return false;                   // Retorna falso
    }
}

int linkedList::getSize()               // Método que retorna o tamanho da lista
{
    return listSize;                    // Retorna o tamanho da lista
}

node* linkedList::getStart(void)        // Método que retorna o ponteiro para o nó inicial
{
    return startNode;                   // Retorna o ponteiro para o nó inicial
}

node* linkedList::getEnd(void)          // Método que retorna o ponteiro para o nó final
{
    return endNode;                     // Retorna o ponteiro para o nó final
}

void linkedList::addStart(int newData)  // Método que adiciona um novo nó no início da lista
{
    node *newPointer;                   // Define um ponteiro para apontar para o novo nó

    try                                 // Inicia tratamento de excessões
    {
        newPointer = new node(newData); // Tenta gerar novo nó
    }
    catch(bad_alloc &fullMemory)        // Caso a memória esteja cheia
    {
        cerr << "Exception ocurred: " << fullMemory.what() << endl; // Reporta o erro
    }

    if(isEmpty())                       // Se a lista estiver vazia
    {
        startNode = newPointer;         // Nó inicial recebe o novo nó
        endNode = newPointer;           // Nó final recebe o novo nó
        listSize = listSize + 1;        // Atualiza o tamanho da lista
    }
    else                                // Se não estiver vazia
    {
        newPointer->pushNext(startNode);    // Aponta o novo nó para o primeiro nó da lista
        startNode->pushLast(newPointer);    // Aponta o primeiro nó da lista para o nó novo
        startNode = newPointer;             // Aponta o novo nó como nó inicial
        listSize = listSize + 1;            // Atualiza o tamanho da lista
    }
}

void linkedList::addEnd(int newData)    // Método que adiciona um novo nó no final da lista
{
    node *newPointer;                   // Define um ponteiro para apontar para o novo nó

    try                                 // Inicia tratamento de excessões
    {
        newPointer = new node(newData); // Tenta gerar novo nó
    }
    catch(bad_alloc &fullMemory)        // Caso a memória esteja cheia
    {
        cerr << "Exception ocurred: " << fullMemory.what() << endl; // Reporta o erro
    }

    if(isEmpty())                       // Se a lista estiver vazia
    {
        startNode = newPointer;         // Nó inicial recebe o novo nó
        endNode = newPointer;           // Nó final recebe o novo nó
        listSize = listSize + 1;        // Atualiza o tamanho da lista
    }
    else                                // Se não estiver vazia
    {
        newPointer->pushLast(endNode);  // Aponta o novo nó para o último nó da lista
        endNode->pushNext(newPointer);  // Aponta o último nó da lista para o nó novo
        endNode = newPointer;           // Aponta o novo nó como nó final
        listSize = listSize + 1;        // Atualiza o tamanho da lista
    }
}

void linkedList::delStart(void)         // Método que deleta o nó no início da lista
{
    if(isEmpty())                       // Se a lista estiver vazia
    {
        throw delEmptyList();           // Inicia tratamento de excessão
    }
    else                                // Se não estiver vazia
    {
        startNode = getStart()->getNext();  // Nó inicial aponta para o próximo nó
        listSize = listSize - 1;            // Atualiza tamanho da lista
    }
}

void linkedList::delEnd(void)           // Método que deleta o nó no final da lista
{
    if(isEmpty())                       // Se a lista estiver vazia
    {
        throw delEmptyList();           // Inicia tratamento de excessão
    }
    else                                // Se não estiver vazia
    {
        endNode = getEnd()->getLast();  // Nó final aponta para o nó anterior
        listSize = listSize - 1;        // Atualiza tamanho da lista
    }
}

class linkedStack : public linkedList   // Define a classe Pilha
{
private:
    linkedList intStack;                // Define a lista para armazenar os dados
public:
    linkedStack();                      // Método construtor da pilha
    ~linkedStack();                     // Método destrutor da pilha
    void push(int);                     // Método para emplihar um dado
    int pop(void);                      // Método para desempilhar um dado
    int top(void);                      // Método para resgatar o valor no topo da pilha
};

linkedStack::linkedStack()              // Método construtor da pilha
{

}

linkedStack::~linkedStack()             // Método destrutor da pilha
{
    cout << "Stack deleted" << endl << endl; // Avisa que a pilha foi deletada
}

void linkedStack::push(int newData)     // Método para emplihar um dado
{
    intStack.addEnd(newData);           // Chama o método da lista para adicionar novo nó
}

int linkedStack::pop()                  // Método para desempilhar um dado
{
    int removedData;                    // Define uma variável para memorizar o dado de retorno

    removedData = intStack.getEnd()->getData(); // Resgata o dado do nó a ser deletado

    try                                 // Inicia tratamento de excessão
    {
        intStack.delEnd();              // Chama o método para deletar o nó no final da pilha
    }
    catch(delEmptyList &delError)       // Caso haja erro
    {
        cerr << delError.what() << endl;    // Reportar o erro
    }

    return removedData;                 // Retorna o dado do nó deletado
}

int linkedStack::top()                  // Método para resgatar o valor no topo da pilha
{
    return intStack.getEnd()->getData();    // Retorna o valor do nó no topo da pilha
}

class linkedQueue : public linkedList   // Define a classe fila
{
private:
    linkedList intQueue;                // Define a lista para armazenar os dados
public:
    linkedQueue();                      // Método construtor da fila
    ~linkedQueue();                     // Método destrutor da fila
    void enqueue(int);                  // Método para adicionar dado na fila
    int dequeue(void);                  // Método para remover dado da fila
    int frente(void);                   // Método que retorna o valor do início da fila
};

linkedQueue::linkedQueue()              // Método construtor da fila
{

}

linkedQueue::~linkedQueue()             // Método destrutor da fila
{
    cout << "Queue deleted" << endl << endl;    // Avisa que a fila foi deletada
}

void linkedQueue::enqueue(int newData)  // Método para adicionar dado na fila
{
    intQueue.addEnd(newData);           // Chama o método da lista para adicionar novo nó
}

int linkedQueue::dequeue(void)          // Método para remover dado da fila
{
    int removedData;                    // Define uma variável para receber o dado do nó deletado

    removedData = intQueue.getStart()->getData();   // Resgata o dado do nó a ser deletado

    try                                 // Inicia tratamento de excessão
    {
        intQueue.delStart();            // Chama o método para deletar o nó no início da fila
    }
    catch(delEmptyList &delError)       // Caso haja erro
    {
        cerr << delError.what() << endl;    // Reportar o erro
    }

    return removedData;                 // Retorna o dado do nó deletado
}

int linkedQueue::frente()               // Método que retorna o valor do início da fila
{
    return intQueue.getStart()->getData();  // Retorna o valor do nó no início da fila
}

int main()
{
    cout << "Testing Stack:" << endl;       // Início dos testes com pilha

    linkedStack *tS;                        // Inicia uma nova pilha
    tS = new linkedStack;

    tS->push(100);                          // Adiciona dado na pilha
    cout << "Pushed 100 to node 1: " << tS->getSize() << endl;
    tS->push(200);                          // Adiciona dado na pilha
    cout << "Pushed 200 to node 2: " << tS->getSize() << endl;
    tS->push(300);                          // Adiciona dado na pilha
    cout << "Pushed 300 to node 3: " << tS->getSize() << endl;
    tS->push(400);                          // Adiciona dado na pilha
    cout << "Pushed 400 to node 4: " << tS->getSize() << endl;
    cout << "Popped data: " << tS->pop() << endl;              // Remove um dado da pila
    cout << "Popped data: " << tS->pop() << endl;              // Remove um dado da pila
    cout << "Popped data: " << tS->pop() << endl;              // Remove um dado da pila

    cout << "Testing bad_alloc Exception:" << endl;

    int allocSize = -1;                     // Variável de teste para memory leak

    do       // Loop para testar memory leak
    {
        cout << allocSize << endl;
        cout << tS->getSize() << endl;
        allocSize = tS->getSize();          // Atualiza o valor de teste com o tamanho atual
        tS->push(100);                      // Adiciona dado na pilha
//        newAllocSize = tS->getSize();          // Atualiza o valor de teste com o tamanho atual
        cout << allocSize << endl;
        cout << tS->getSize() << endl;
    } while(allocSize != tS->getSize());

    delete tS;                              // Deleta a pilha

    cout << "Testing Queue:" << endl;       // Início dos testes com fila

    linkedQueue *tQ;                        // Inicia uma nova fila
    tQ = new linkedQueue;

    tQ->enqueue(100);                       // Adiciona dado na fila
    cout << "Enqueued 100 to node 1: " << tQ->getSize() << endl;
    tQ->enqueue(200);                       // Adiciona dado na fila
    cout << "Enqueued 200 to node 2: " << tQ->getSize() << endl;
    cout << "Dequeued data: " << tQ->dequeue() << endl;          // Remove um dado da fila
    cout << "Dequeued data: " << tQ->dequeue() << endl;          // Remove um dado da fila
    cout << "Testing dequeue on empty queue:" << endl;
    cout << "Dequeued data: " << tQ->dequeue() << endl;          // Remove um dado da fila

    delete tQ;                              // Deleta a fila

    return 0;
}
